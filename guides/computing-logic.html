<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta content='width=device-width, initial-scale=1.0' name="viewport"><title>Computing & Logic - Rebuild Civilization Compendium</title><link rel="stylesheet" href="css/shared.css"><style>nav.toc{background:var(--surface);padding:2rem;border-radius:6px;margin-bottom:3rem;border-left:4px solid var(--accent)}nav.toc h2{color:var(--accent2);margin-bottom:1.5rem;font-size:1.4rem}nav.toc ol{list-style-position:inside;display:grid;grid-template-columns:1fr 1fr;gap:1rem}navsection h2{color:var(--accent2);font-size:1.8rem;margin-bottom:1.5rem;padding-bottom:.5rem;border-bottom:1px solid var(--border)}section h3{color:var(--accent);font-size:1.2rem;margin-top:1.5rem;margin-bottom:.8rem}section p{margin-bottom:1rem;color:var(--text)}.subsection{background:var(--card);padding:1.5rem;margin:1.5rem 0;border-radius:4px;border-left:3px solid var(--accent)}.subsection h4{color:var(--accent2);margin-bottom:.7rem}.code-block{background:#0a0a15;padding:1rem;border-radius:4px;overflow-x:auto;margin:1rem 0;border-left:3px solid var(--accent2);font-family:'Courier New',monospace;color:var(--accent2);font-size:.9rem}table th{background:var(--accent);color:var(--bg);padding:.8rem;text-align:left}table td{padding:.8rem;border-bottom:1px solid var(--border)}table tr:hover{background:#2d2416aa}.svg-container{background:var(--card);padding:1.5rem;margin:1.5rem 0;border-radius:6px;display:flex;justify-content:center;overflow-x:auto}.highlight{color:var(--accent2);font-weight:600}.note{background:var(--card);padding:1rem;border-left:3px solid var(--muted);margin:1rem 0;border-radius:4px;font-style:italic}</style></head><body><main role="main"><a class="skip-link" href="#main-content"> Skip to main content </a><header><h1> Computing & Logic </h1><div class="top-controls"><button class="theme-toggle" aria-label='Toggle dark/light theme' id="theme-toggle" title='Toggle dark/light mode'> ‚òÄÔ∏è </button><button class="mark-read-btn" aria-label='Mark this guide as read' id="mark-read-btn" title='Mark this guide as completed'> Mark as Read </button></div><div class="guide-metadata"><span class="difficulty"> Difficulty: ‚óè‚óè‚óè‚óè‚óã </span><span class="read-time"> üìñ ~14 min read </span></div><p> From Tally Marks to Electronic Computers </p></header><div class="container"><a class="back-link" href="../index.html" aria-label='Back to guide list'> ‚Üê Back to Index </a><nav class="toc" role="navigation" aria-label='Table of contents'><h2> Table of Contents </h2><ol><li><a href="#counting-systems"> Counting Systems </a></li><li><a href="#abacus"> The Abacus </a></li><li><a href="#binary"> Binary Number System </a></li><li><a href="#boolean-logic"> Boolean Logic </a></li><li><a href="#mechanical"> Mechanical Computing </a></li><li><a href="#relay-logic"> Relay Logic </a></li><li><a href="#vacuum-tubes"> Vacuum Tubes </a></li><li><a href="#transistors"> Transistors </a></li><li><a href="#digital-circuits"> Digital Circuits </a></li><li><a href="#memory-storage"> Memory & Storage </a></li><li><a href="#programming"> Programming Fundamentals </a></li><li><a href="#path-forward"> The Path Forward </a></li></ol></nav><section id="counting-systems"><h2> 1. Counting Systems </h2><p> Before machines can think, we need a way to represent numbers. Different civilizations developed different methods, each suited to their tools and needs. </p><div class="subsection"><h4> Tally Marks </h4><p> The simplest counting system uses single marks for each unit. In many cultures, five marks are crossed through to represent groups of five: </p><div class="code-block"> | = 1 || = 2 ||| = 3 |||| = 4 ‚ï±|||| = 5 ‚ï±|||| ‚ï±|||| = 10 </div><p> Tally marks are intuitive but become unwieldy for large numbers. </p></div><div class="subsection"><h4> Base-10 (Decimal) </h4><p> The decimal system, used almost universally today, likely developed because humans have ten fingers. Each position represents a power of 10: </p><div class="code-block"> 345 = (3 √ó 10¬≤) + (4 √ó 10¬π) + (5 √ó 10‚Å∞) = (3 √ó 100) + (4 √ó 10) + (5 √ó 1) = 300 + 40 + 5 </div><p> This <span class="highlight"> positional notation </span> is efficient for human calculation and allows representation of arbitrarily large numbers. </p></div><div class="subsection"><h4> Base-2 (Binary) </h4><p> With only two digits (0 and 1), binary is ideal for machines because it requires only two physical states: </p><div class="code-block"> 101‚ÇÇ = (1 √ó 2¬≤) + (0 √ó 2¬π) + (1 √ó 2‚Å∞) = (1 √ó 4) + (0 √ó 2) + (1 √ó 1) = 4 + 0 + 1 = 5‚ÇÅ‚ÇÄ </div><p><span class="highlight"> Why binary matters for machines: </span> A switch can be ON (1) or OFF (0). A voltage can be HIGH (1) or LOW (0). A hole in a card can be PRESENT (1) or ABSENT (0). Two states map naturally to binary digits, making binary the perfect choice for electronic computation. </p></div><div class="subsection"><h4> Base-16 (Hexadecimal) </h4><p> Hexadecimal uses digits 0-9 and letters A-F (where A=10, B=11, ... F=15). It's convenient because each hex digit represents exactly four binary digits: </p><div class="code-block"> AF‚ÇÅ‚ÇÜ = (10 √ó 16¬π) + (15 √ó 16‚Å∞) = 160 + 15 = 175‚ÇÅ‚ÇÄ 1010 1111‚ÇÇ = AF‚ÇÅ‚ÇÜ This makes hex useful for representing binary data in a compact, human-readable form. </div></div></section><section id="abacus"><h2> 2. The Abacus </h2><p> One of humanity's first computing devices, the abacus is a frame with rods holding movable beads. By moving beads, users can perform arithmetic with remarkable speed and accuracy. </p><h3> Construction and Operation </h3><p> A typical abacus has: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Horizontal rods representing place values (units, tens, hundreds, etc.) </li><li> Beads on each rod (typically 10 per rod for decimal systems) </li><li> A dividing bar separating upper and lower sections (for advanced techniques) </li></ul><p> Each position's value is determined by <span class="highlight"> how many beads are moved toward the dividing bar </span> . To add 3 + 5: </p><ol style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Move 3 beads on the units rod toward the bar </li><li> Move 5 more beads on the same rod toward the bar </li><li> You now have 8 beads toward the bar = 8 </li></ol><p> Subtraction, multiplication, and even division are possible on an abacus, though multiplication requires understanding place value and repeated addition. </p><h3> Abacus Diagram </h3><div class="svg-container"><svg height="250" viewbox='0 0 400 250' width="400" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 1'><rect fill="none" height="210" stroke="#53d8a8" stroke-width="2" width="360" x="20" y="20"></rect><line stroke="#53d8a8" stroke-width="1" x1="20" x2="10" y1="20" y2="15"></line><line stroke="#53d8a8" stroke-width="1" x1="380" x2="390" y1="20" y2="15"></line><line stroke="#e94560" stroke-width="2" x1="20" x2="380" y1="120" y2="120"></line><text fill="#aaa" font-size="12" text-anchor="end" x="10" y="75"> Hundreds </text><text fill="#aaa" font-size="12" text-anchor="end" x="10" y="165"> Tens </text><line stroke="#aaa" stroke-width="1" x1="50" x2="350" y1="70" y2="70"></line><circle cx="70" cy="70" fill="#53d8a8" r="6"></circle><circle cx="85" cy="70" fill="#53d8a8" r="6"></circle><circle cx="130" cy="70" fill="#e94560" r="8"></circle><circle cx="155" cy="70" fill="#e94560" r="8"></circle><circle cx="180" cy="70" fill="#e94560" r="8"></circle><circle cx="205" cy="70" fill="#e94560" r="8"></circle><circle cx="230" cy="70" fill="#e94560" r="8"></circle><line stroke="#aaa" stroke-width="1" x1="50" x2="350" y1="160" y2="160"></line><circle cx="70" cy="160" fill="#53d8a8" r="6"></circle><circle cx="85" cy="160" fill="#53d8a8" r="6"></circle><circle cx="130" cy="160" fill="#e94560" r="8"></circle><circle cx="155" cy="160" fill="#e94560" r="8"></circle><circle cx="180" cy="160" fill="#e94560" r="8"></circle><circle cx="280" cy="160" fill="#888" r="8"></circle><circle cx="305" cy="160" fill="#888" r="8"></circle><text fill="#53d8a8" font-size="14" font-weight="bold" text-anchor="middle" x="200" y="195"> Value: 30 </text></svg></div><p class="note"> A skilled abacus user can perform calculations nearly as fast as a modern calculator, demonstrating that computation doesn't require electricity‚Äîonly a systematic method and physical representation of numbers. </p></section><section id="binary"><h2> 3. Binary Number System </h2><p> Binary is the language of computers. Everything a computer does ultimately comes down to manipulating binary digits (bits)‚Äîsequences of 1s and 0s. </p><h3> Converting Decimal to Binary </h3><p> To convert a decimal number to binary, repeatedly divide by 2 and record the remainders: </p><div class="code-block"> 13 √∑ 2 = 6 remainder 1 6 √∑ 2 = 3 remainder 0 3 √∑ 2 = 1 remainder 1 1 √∑ 2 = 0 remainder 1 Read remainders bottom to top: 1101‚ÇÇ = 13‚ÇÅ‚ÇÄ </div><h3> Converting Binary to Decimal </h3><p> Multiply each bit by its position value (power of 2) and sum: </p><div class="code-block"> 1011‚ÇÇ = (1√ó8) + (0√ó4) + (1√ó2) + (1√ó1) = 8 + 0 + 2 + 1 = 11‚ÇÅ‚ÇÄ </div><h3> Binary Arithmetic </h3><div class="subsection"><h4> Binary Addition </h4><p> Rules: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (0 with carry 1) </p><div class="code-block"> 1010 (10‚ÇÅ‚ÇÄ) + 101 ( 5‚ÇÅ‚ÇÄ) ------- 1111 (15‚ÇÅ‚ÇÄ) </div></div><div class="subsection"><h4> Binary Multiplication </h4><p> Like decimal multiplication, but with only 0 and 1: </p><div class="code-block"> 101 (5‚ÇÅ‚ÇÄ) √ó 11 (3‚ÇÅ‚ÇÄ) ----- 101 101 ----- 1111 (15‚ÇÅ‚ÇÄ) </div></div><h3> Reference Table: Decimal 0-255 in Binary </h3><table><tr><th scope="row"> Decimal </th><th scope="row"> Binary </th><th scope="row"> Decimal </th><th scope="row"> Binary </th><th scope="row"> Decimal </th><th scope="row"> Binary </th></tr><tr><td> 0 </td><td> 00000000 </td><td> 85 </td><td> 01010101 </td><td> 170 </td><td> 10101010 </td></tr><tr><td> 1 </td><td> 00000001 </td><td> 86 </td><td> 01010110 </td><td> 171 </td><td> 10101011 </td></tr><tr><td> 2 </td><td> 00000010 </td><td> 87 </td><td> 01010111 </td><td> 172 </td><td> 10101100 </td></tr><tr><td> 3 </td><td> 00000011 </td><td> 88 </td><td> 01011000 </td><td> 173 </td><td> 10101101 </td></tr><tr><td> 4 </td><td> 00000100 </td><td> 89 </td><td> 01011001 </td><td> 174 </td><td> 10101110 </td></tr><tr><td> 15 </td><td> 00001111 </td><td> 100 </td><td> 01100100 </td><td> 200 </td><td> 11001000 </td></tr><tr><td> 16 </td><td> 00010000 </td><td> 127 </td><td> 01111111 </td><td> 255 </td><td> 11111111 </td></tr></table><p class="note"> An 8-bit binary number (one byte) can represent values from 0 to 255. A 16-bit number can represent 0 to 65,535. The number of bits determines the range of values a computer can work with. </p></section><section id="boolean-logic"><h2> 4. Boolean Logic </h2><p><span class="highlight"> Boolean logic </span> is a system of logic using only two values: TRUE (1) and FALSE (0). Logic gates combine these values according to mathematical rules, forming the foundation of all digital computation. </p><div class="subsection"><h4> AND Gate </h4><p> Output is TRUE only if ALL inputs are TRUE. </p><table><tr><th scope="row"> A </th><th scope="row"> B </th><th scope="row"> A AND B </th></tr><tr><td> 0 </td><td> 0 </td><td> 0 </td></tr><tr><td> 0 </td><td> 1 </td><td> 0 </td></tr><tr><td> 1 </td><td> 0 </td><td> 0 </td></tr><tr><td> 1 </td><td> 1 </td><td> 1 </td></tr></table></div><div class="subsection"><h4> OR Gate </h4><p> Output is TRUE if ANY input is TRUE. </p><table><tr><th scope="row"> A </th><th scope="row"> B </th><th scope="row"> A OR B </th></tr><tr><td> 0 </td><td> 0 </td><td> 0 </td></tr><tr><td> 0 </td><td> 1 </td><td> 1 </td></tr><tr><td> 1 </td><td> 0 </td><td> 1 </td></tr><tr><td> 1 </td><td> 1 </td><td> 1 </td></tr></table></div><div class="subsection"><h4> NOT Gate </h4><p> Output is the opposite of the input (inverts the signal). </p><table><tr><th scope="row"> A </th><th scope="row"> NOT A </th></tr><tr><td> 0 </td><td> 1 </td></tr><tr><td> 1 </td><td> 0 </td></tr></table></div><div class="subsection"><h4> XOR Gate (Exclusive OR) </h4><p> Output is TRUE if inputs are DIFFERENT. </p><table><tr><th scope="row"> A </th><th scope="row"> B </th><th scope="row"> A XOR B </th></tr><tr><td> 0 </td><td> 0 </td><td> 0 </td></tr><tr><td> 0 </td><td> 1 </td><td> 1 </td></tr><tr><td> 1 </td><td> 0 </td><td> 1 </td></tr><tr><td> 1 </td><td> 1 </td><td> 0 </td></tr></table></div><div class="subsection"><h4> NAND Gate </h4><p> NOT AND: Output is FALSE only if ALL inputs are TRUE. </p><table><tr><th scope="row"> A </th><th scope="row"> B </th><th scope="row"> A NAND B </th></tr><tr><td> 0 </td><td> 0 </td><td> 1 </td></tr><tr><td> 0 </td><td> 1 </td><td> 1 </td></tr><tr><td> 1 </td><td> 0 </td><td> 1 </td></tr><tr><td> 1 </td><td> 1 </td><td> 0 </td></tr></table><p><span class="highlight"> NAND is universal: </span> Every logic function can be built using only NAND gates. This makes NAND the most efficient basic building block for digital circuits. </p></div><h3> Logic Gate Symbols </h3><div class="svg-container"><svg height="320" viewbox='0 0 600 320' width="600" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 2'><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="30" y="30"> AND </text><line stroke="#e94560" stroke-width="2" x1="20" x2="40" y1="50" y2="50"></line><line stroke="#e94560" stroke-width="2" x1="20" x2="40" y1="70" y2="70"></line><path d='M 40 45 L 40 75 Q 60 75 60 60 Q 60 45 40 45' fill="none" stroke="#53d8a8" stroke-width="2"></path><line stroke="#53d8a8" stroke-width="2" x1="60" x2="80" y1="60" y2="60"></line><circle cx="80" cy="60" fill="#53d8a8" r="3"></circle></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="130" y="30"> OR </text><line stroke="#e94560" stroke-width="2" x1="120" x2="140" y1="50" y2="50"></line><line stroke="#e94560" stroke-width="2" x1="120" x2="140" y1="70" y2="70"></line><path d='M 140 45 Q 145 45 160 60 Q 145 75 140 75 Q 145 70 145 50' fill="none" stroke="#53d8a8" stroke-width="2"></path><line stroke="#53d8a8" stroke-width="2" x1="160" x2="180" y1="60" y2="60"></line><circle cx="180" cy="60" fill="#53d8a8" r="3"></circle></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="230" y="30"> NOT </text><line stroke="#e94560" stroke-width="2" x1="220" x2="240" y1="60" y2="60"></line><path d='M 240 50 L 260 60 L 240 70 Z' fill="none" stroke="#53d8a8" stroke-width="2"></path><circle cx="265" cy="60" fill="none" r="4" stroke="#53d8a8" stroke-width="2"></circle><line stroke="#53d8a8" stroke-width="2" x1="269" x2="285" y1="60" y2="60"></line></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="330" y="30"> XOR </text><line stroke="#e94560" stroke-width="2" x1="320" x2="340" y1="50" y2="50"></line><line stroke="#e94560" stroke-width="2" x1="320" x2="340" y1="70" y2="70"></line><path d='M 343 45 Q 348 45 360 60 Q 348 75 343 75 Q 348 70 348 50' fill="none" stroke="#53d8a8" stroke-width="2"></path><path d='M 340 45 Q 345 45 357 60 Q 345 75 340 75' fill="none" stroke="#53d8a8" stroke-width="1"></path><line stroke="#53d8a8" stroke-width="2" x1="360" x2="380" y1="60" y2="60"></line><circle cx="380" cy="60" fill="#53d8a8" r="3"></circle></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="430" y="30"> NAND </text><line stroke="#e94560" stroke-width="2" x1="420" x2="440" y1="50" y2="50"></line><line stroke="#e94560" stroke-width="2" x1="420" x2="440" y1="70" y2="70"></line><path d='M 440 45 L 440 75 Q 460 75 460 60 Q 460 45 440 45' fill="none" stroke="#53d8a8" stroke-width="2"></path><circle cx="465" cy="60" fill="none" r="4" stroke="#53d8a8" stroke-width="2"></circle><line stroke="#53d8a8" stroke-width="2" x1="469" x2="485" y1="60" y2="60"></line></g><text fill="#aaa" font-size="12" x="30" y="130"> Input </text><line stroke="#e94560" stroke-width="2" x1="30" x2="80" y1="140" y2="140"></line><text fill="#aaa" font-size="12" x="30" y="160"> Output </text><line stroke="#53d8a8" stroke-width="2" x1="30" x2="80" y1="170" y2="170"></line><text fill="#53d8a8" font-size="13" font-weight="bold" x="30" y="210"> AND Truth Table </text><text fill="#eee" font-size="11" x="30" y="235"> 0 AND 0 = 0 </text><text fill="#eee" font-size="11" x="30" y="255"> 0 AND 1 = 0 </text><text fill="#eee" font-size="11" x="30" y="275"> 1 AND 0 = 0 </text><text fill="#eee" font-size="11" x="30" y="295"> 1 AND 1 = 1 </text><text fill="#53d8a8" font-size="13" font-weight="bold" x="320" y="210"> NAND Universality </text><text fill="#eee" font-size="11" x="320" y="235"> Can build AND, OR, NOT, </text><text fill="#eee" font-size="11" x="320" y="255"> XOR, and every other logic </text><text fill="#eee" font-size="11" x="320" y="275"> gate using only NAND </text><text fill="#eee" font-size="11" x="320" y="295"> gates. Maximum efficiency! </text></svg></div></section><section id="mechanical"><h2> 5. Mechanical Computing </h2><p> Before electronics, machines performed calculations using gears, cams, and mechanical linkages. These devices demonstrate that computation is fundamentally about manipulating physical objects according to rules. </p><h3> Charles Babbage's Difference Engine </h3><p> In the 1820s, Charles Babbage conceived of the <span class="highlight"> Difference Engine </span> , a machine to calculate polynomial functions using the method of differences. It featured: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Mechanical columns representing numbers (each digit a separate wheel) </li><li> Automatic carry mechanism (when a wheel turns past 9, it increments the next column) </li><li> Programmable operation through mechanical arrangement </li></ul><h3> The Analytical Engine </h3><p> Babbage's later <span class="highlight"> Analytical Engine </span> (1840s) included: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> A "mill" (processor) performing arithmetic </li><li> A "store" (memory) holding numbers </li><li> Control mechanisms using punched cards (borrowed from the Jacquard loom) </li><li> The ability to perform conditional branching </li></ul><p> The Analytical Engine contained the conceptual elements of modern computers, though Babbage never fully constructed it. </p><h3> The Jacquard Loom </h3><p> In 1804, Joseph Marie Jacquard invented a loom controlled by punched cards. Each card described one row of the pattern; the holes determined which threads were raised. This was the first large-scale programmable machine, and it inspired Babbage's use of cards for the Analytical Engine. </p><p class="note"> The Jacquard loom demonstrates that you don't need electronic computers for programmability‚Äîyou need a systematic way to encode instructions (the punched card) and a mechanism to read and obey them (the reader mechanism). </p><h3> Mechanical Logic with Gears </h3><div class="svg-container"><svg height="250" viewbox='0 0 500 250' width="500" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 3'><text fill="#53d8a8" font-size="16" font-weight="bold" text-anchor="middle" x="250" y="25"> Gear-Based Mechanical AND Gate </text><g><text fill="#aaa" font-size="12" text-anchor="middle" x="80" y="70"> Input A </text><circle cx="80" cy="100" fill="none" r="30" stroke="#e94560" stroke-width="2"></circle><circle cx="80" cy="100" fill="#e94560" r="5"></circle><line stroke="#e94560" stroke-width="2" x1="80" x2="80" y1="70" y2="60"></line><line stroke="#e94560" stroke-width="2" x1="110" x2="120" y1="100" y2="100"></line></g><g><text fill="#aaa" font-size="12" text-anchor="middle" x="420" y="70"> Input B </text><circle cx="420" cy="100" fill="none" r="30" stroke="#e94560" stroke-width="2"></circle><circle cx="420" cy="100" fill="#e94560" r="5"></circle><line stroke="#e94560" stroke-width="2" x1="420" x2="420" y1="70" y2="60"></line><line stroke="#e94560" stroke-width="2" x1="390" x2="380" y1="100" y2="100"></line></g><g><text fill="#aaa" font-size="12" text-anchor="middle" x="250" y="160"> Output (A AND B) </text><circle cx="250" cy="120" fill="none" r="45" stroke="#53d8a8" stroke-width="2"></circle><circle cx="250" cy="120" fill="#53d8a8" r="8"></circle><line stroke="#53d8a8" stroke-width="2" x1="250" x2="250" y1="75" y2="60"></line><line stroke="#53d8a8" stroke-width="2" x1="295" x2="310" y1="120" y2="120"></line><line stroke="#53d8a8" stroke-width="2" x1="205" x2="190" y1="120" y2="120"></line></g><text fill="#aaa" font-size="11" text-anchor="middle" x="250" y="200"> Both input gears must turn to engage </text><text fill="#aaa" font-size="11" text-anchor="middle" x="250" y="217"> the output gear. If either input is OFF, </text><text fill="#aaa" font-size="11" text-anchor="middle" x="250" y="234"> the output gear cannot turn (AND logic). </text></svg></div></section><section id="relay-logic"><h2> 6. Relay Logic </h2><p> An <span class="highlight"> electromagnetic relay </span> is a switch controlled by electricity. When current flows through a coil, it creates a magnetic field that pulls a metal contact, closing (or opening) an electrical circuit. Relays bridged the gap between mechanical and electronic computing. </p><h3> How a Relay Works </h3><p> A relay has: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> A coil of wire (input circuit) </li><li> An electromagnet that activates when current flows </li><li> A mechanical switch (output circuit) that closes or opens </li></ul><p> One relay can control another, allowing relay logic to build complex switching networks. <span class="highlight"> Mark I (1944) </span> , one of the first computers, used 3,300 relays. </p><h3> Building Logic Gates from Relays </h3><div class="svg-container"><svg height="400" viewbox='0 0 600 400' width="600" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 4'><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="80" y="30"> AND Gate (Two Relays in Series) </text><text fill="#aaa" font-size="11" x="20" y="70"> Input A: </text><line stroke="#aaa" stroke-width="1" x1="20" x2="40" y1="80" y2="80"></line><circle cx="40" cy="80" fill="#e94560" r="4"></circle><g><rect fill="none" height="30" stroke="#53d8a8" stroke-width="2" width="30" x="50" y="65"></rect><text fill="#53d8a8" font-size="10" text-anchor="middle" x="65" y="85"> RA </text></g><g><line stroke="#aaa" stroke-width="1" x1="100" x2="115" y1="80" y2="80"></line><line stroke="#aaa" stroke-width="2" x1="115" x2="115" y1="75" y2="85"></line><circle cx="115" cy="80" fill="#53d8a8" r="2"></circle></g><text fill="#aaa" font-size="11" x="20" y="120"> Input B: </text><line stroke="#aaa" stroke-width="1" x1="20" x2="40" y1="130" y2="130"></line><circle cx="40" cy="130" fill="#e94560" r="4"></circle><g><rect fill="none" height="30" stroke="#53d8a8" stroke-width="2" width="30" x="50" y="115"></rect><text fill="#53d8a8" font-size="10" text-anchor="middle" x="65" y="135"> RB </text></g><g><line stroke="#aaa" stroke-width="1" x1="100" x2="115" y1="130" y2="130"></line><line stroke="#aaa" stroke-width="2" x1="115" x2="115" y1="125" y2="135"></line><circle cx="115" cy="130" fill="#53d8a8" r="2"></circle></g><line stroke="#aaa" stroke-width="1" x1="115" x2="130" y1="80" y2="80"></line><line stroke="#aaa" stroke-width="1" x1="130" x2="130" y1="80" y2="130"></line><line stroke="#aaa" stroke-width="1" x1="130" x2="115" y1="130" y2="130"></line><text fill="#53d8a8" font-size="11" font-weight="bold" x="140" y="106"> Output </text><text fill="#aaa" font-size="10" x="140" y="122"> (both needed) </text></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="330" y="30"> OR Gate (Two Relays in Parallel) </text><text fill="#aaa" font-size="11" x="280" y="70"> Input A: </text><line stroke="#aaa" stroke-width="1" x1="280" x2="300" y1="80" y2="80"></line><circle cx="300" cy="80" fill="#e94560" r="4"></circle><g><rect fill="none" height="30" stroke="#53d8a8" stroke-width="2" width="30" x="310" y="65"></rect><text fill="#53d8a8" font-size="10" text-anchor="middle" x="325" y="85"> RA </text></g><g><line stroke="#aaa" stroke-width="1" x1="360" x2="375" y1="80" y2="80"></line><line stroke="#aaa" stroke-width="2" x1="375" x2="375" y1="75" y2="85"></line><circle cx="375" cy="80" fill="#53d8a8" r="2"></circle></g><text fill="#aaa" font-size="11" x="280" y="140"> Input B: </text><line stroke="#aaa" stroke-width="1" x1="280" x2="300" y1="150" y2="150"></line><circle cx="300" cy="150" fill="#e94560" r="4"></circle><g><rect fill="none" height="30" stroke="#53d8a8" stroke-width="2" width="30" x="310" y="135"></rect><text fill="#53d8a8" font-size="10" text-anchor="middle" x="325" y="155"> RB </text></g><g><line stroke="#aaa" stroke-width="1" x1="360" x2="375" y1="150" y2="150"></line><line stroke="#aaa" stroke-width="2" x1="375" x2="375" y1="145" y2="155"></line><circle cx="375" cy="150" fill="#53d8a8" r="2"></circle></g><line stroke="#aaa" stroke-width="1" x1="375" x2="390" y1="80" y2="80"></line><line stroke="#aaa" stroke-width="1" x1="375" x2="390" y1="150" y2="150"></line><line stroke="#aaa" stroke-width="1" x1="390" x2="390" y1="80" y2="150"></line><line stroke="#aaa" stroke-width="1" x1="390" x2="410" y1="115" y2="115"></line><text fill="#53d8a8" font-size="11" font-weight="bold" x="420" y="106"> Output </text><text fill="#aaa" font-size="10" x="420" y="122"> (either works) </text></g><g><text fill="#53d8a8" font-size="12" font-weight="bold" x="60" y="250"> Relay Advantages: </text><text fill="#eee" font-size="11" x="60" y="270"> ‚Ä¢ Mechanical (no mysterious electricity) </text><text fill="#eee" font-size="11" x="60" y="285"> ‚Ä¢ Can switch large currents </text><text fill="#eee" font-size="11" x="60" y="300"> ‚Ä¢ Reliable for many cycles </text><text fill="#e94560" font-size="12" font-weight="bold" x="60" y="330"> Relay Disadvantages: </text><text fill="#eee" font-size="11" x="60" y="350"> ‚Ä¢ Slow (mechanical movement takes milliseconds) </text><text fill="#eee" font-size="11" x="60" y="365"> ‚Ä¢ Power-hungry </text><text fill="#eee" font-size="11" x="60" y="380"> ‚Ä¢ Bulky (thousands of relays fill entire rooms) </text></g></svg></div><p class="note"> Relay computers like the Mark I could perform calculations, but they were slow, power-hungry, and required constant maintenance. A single relay failure could stop the entire machine. Relays foreshadowed the need for faster switching devices. </p></section><section id="vacuum-tubes"><h2> 7. Vacuum Tubes </h2><p> A <span class="highlight"> vacuum tube </span> (or valve) is an electronic device that uses the flow of electrons through a vacuum to amplify or switch electrical signals. Unlike relays, tubes have no moving parts, so they can switch millions of times per second. </p><h3> The Triode </h3><p> A triode tube has three electrodes: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li><span class="highlight"> Cathode: </span> Heated filament that emits electrons </li><li><span class="highlight"> Grid: </span> Control electrode between cathode and anode. A small voltage on the grid controls electron flow. </li><li><span class="highlight"> Anode (Plate): </span> Receives electrons, creating output current </li></ul><p> When the grid is negatively charged, it repels electrons and blocks current (OFF). When positively charged, it allows electrons through (ON). The grid voltage acts as a switch or amplifier. </p><h3> Triode Cross-Section Diagram </h3><div class="svg-container"><svg height="280" viewbox='0 0 500 280' width="500" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 5'><ellipse cx="250" cy="140" fill="none" rx="140" ry="110" stroke="#53d8a8" stroke-width="2"></ellipse><ellipse cx="250" cy="140" fill="#0a0a15" opacity="0.3" rx="130" ry="100"></ellipse><g><text fill="#aaa" font-size="12" text-anchor="middle" x="250" y="240"> Cathode (filament) </text><rect fill="none" height="8" stroke="#e94560" stroke-width="2" width="40" x="230" y="210"></rect><line stroke="#666" stroke-width="2" x1="230" x2="220" y1="225" y2="240"></line><line stroke="#666" stroke-width="2" x1="270" x2="280" y1="225" y2="240"></line></g><g><text fill="#aaa" font-size="12" x="120" y="145"> Grid </text><circle cx="250" cy="140" fill="none" r="45" stroke="#e94560" stroke-dasharray="3,3" stroke-width="1"></circle><line stroke="#e94560" stroke-width="1" x1="250" x2="250" y1="95" y2="185"></line><line stroke="#e94560" stroke-width="1" x1="205" x2="295" y1="140" y2="140"></line><line stroke="#666" stroke-width="2" x1="250" x2="242" y1="100" y2="75"></line><line stroke="#666" stroke-width="2" x1="242" x2="230" y1="75" y2="50"></line></g><g><text fill="#aaa" font-size="12" x="370" y="65"> Anode (Plate) </text><rect fill="none" height="10" stroke="#53d8a8" stroke-width="2" width="60" x="360" y="30"></rect><line stroke="#666" stroke-width="2" x1="390" x2="390" y1="30" y2="15"></line></g><g fill="none" stroke="#53d8a8" stroke-dasharray="5,5" stroke-width="1.5"><line x1="240" x2="235" y1="215" y2="180"></line><line x1="250" x2="250" y1="215" y2="190"></line><line x1="260" x2="265" y1="215" y2="180"></line><text fill="#53d8a8" font-size="10" x="270" y="200"> Electron flow </text></g><g><text fill="#aaa" font-size="11" x="30" y="55"> Input signal </text><text fill="#aaa" font-size="11" x="30" y="70"> (grid voltage) </text><line stroke="#aaa" stroke-width="1" x1="40" x2="240" y1="45" y2="75"></line><text fill="#aaa" font-size="11" x="420" y="55"> Output signal </text><text fill="#aaa" font-size="11" x="420" y="70"> (anode current) </text><line stroke="#aaa" stroke-width="1" x1="390" x2="420" y1="20" y2="45"></line></g></svg></div><h3> Building Logic Gates from Tubes </h3><p> A tube can function as a NOT gate: low input voltage (grid near ground) allows high anode current (output HIGH). High input voltage blocks electrons, producing low output (LOW). Other gates can be built by combining tubes, similar to relay logic but much faster. </p><p class="note"> The first large-scale electronic computer, <span class="highlight"> ENIAC </span> (1946), used 18,000 vacuum tubes. It performed calculations 1000 times faster than relay computers but consumed 150 kilowatts of power and required constant tube replacement. The tubes were the most frequent cause of failure. </p></section><section id="transistors"><h2> 8. Transistors </h2><p> A <span class="highlight"> transistor </span> is a semiconductor device that acts as an electronic switch or amplifier. Invented in 1947, transistors are smaller, faster, more reliable, and far more power-efficient than vacuum tubes. </p><h3> How Semiconductors Work </h3><p> A semiconductor is a material (like silicon) with conductivity between conductors and insulators. By adding impurities (doping): </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li><span class="highlight"> N-type (negative): </span> Extra electrons, donate negative charges </li><li><span class="highlight"> P-type (positive): </span> Missing electrons (holes), accept electrons </li></ul><p> A junction between P and N layers creates a diode (one-way valve). By using multiple layers, we create transistors. </p><h3> NPN and PNP Transistors </h3><div class="svg-container"><svg height="300" viewbox='0 0 550 300' width="550" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 6'><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="100" y="30"> NPN Transistor </text><circle cx="100" cy="80" fill="none" r="25" stroke="#53d8a8" stroke-width="2"></circle><line stroke="#53d8a8" stroke-width="2" x1="100" x2="100" y1="55" y2="35"></line><text fill="#aaa" font-size="11" x="115" y="40"> C (Collector) </text><line stroke="#e94560" stroke-width="2" x1="75" x2="55" y1="80" y2="80"></line><text fill="#aaa" font-size="11" x="30" y="85"> B (Base) </text><line stroke="#53d8a8" stroke-width="2" x1="100" x2="100" y1="105" y2="125"></line><polygon fill="#53d8a8" points='100,105 95,112 105,112'></polygon><text fill="#aaa" font-size="11" x="115" y="130"> E (Emitter) </text><text fill="#aaa" font-size="9" x="85" y="85"> P </text><text fill="#eee" font-size="11" x="50" y="160"> Control current at base </text><text fill="#eee" font-size="11" x="50" y="177"> switches current from </text><text fill="#eee" font-size="11" x="50" y="194"> collector to emitter </text></g><g><text fill="#53d8a8" font-size="14" font-weight="bold" x="350" y="30"> PNP Transistor </text><circle cx="350" cy="80" fill="none" r="25" stroke="#53d8a8" stroke-width="2"></circle><line stroke="#53d8a8" stroke-width="2" x1="350" x2="350" y1="55" y2="35"></line><text fill="#aaa" font-size="11" x="365" y="40"> C (Collector) </text><line stroke="#e94560" stroke-width="2" x1="325" x2="305" y1="80" y2="80"></line><text fill="#aaa" font-size="11" x="280" y="85"> B (Base) </text><line stroke="#53d8a8" stroke-width="2" x1="350" x2="350" y1="105" y2="125"></line><polygon fill="#53d8a8" points='350,105 345,112 355,112' transform='rotate(180 350 112)'></polygon><text fill="#aaa" font-size="11" x="365" y="130"> E (Emitter) </text><text fill="#aaa" font-size="9" x="335" y="85"> N </text><text fill="#eee" font-size="11" x="300" y="160"> Control current at base </text><text fill="#eee" font-size="11" x="300" y="177"> switches current from </text><text fill="#eee" font-size="11" x="300" y="194"> emitter to collector </text></g><g><text fill="#53d8a8" font-size="12" font-weight="bold" x="50" y="260"> Why Transistors Changed Everything: </text><text fill="#eee" font-size="10" x="50" y="280"> ‚Ä¢ 1000x smaller than vacuum tubes ‚Ä¢ 1000x less power ‚Ä¢ Millions can fit on a chip ‚Ä¢ Reliable (decades of life) ‚Ä¢ Cheap to manufacture </text></g></svg></div><p class="note"> The transistor was the killer innovation that made modern computers possible. By the 1960s, transistors replaced tubes, and in the 1970s, millions of transistors were packed into single chips (integrated circuits). This exponential miniaturization continues today. </p></section><section id="digital-circuits"><h2> 9. Digital Circuits </h2><p> The fundamental building blocks of computers are circuits that perform specific functions. These can be combined to create arithmetic units, memory, and processors. </p><h3> The Half Adder </h3><p> A half adder adds two single-bit numbers and produces a sum and a carry-out: </p><table><tr><th scope="row"> A </th><th scope="row"> B </th><th scope="row"> Sum </th><th scope="row"> Carry </th></tr><tr><td> 0 </td><td> 0 </td><td> 0 </td><td> 0 </td></tr><tr><td> 0 </td><td> 1 </td><td> 1 </td><td> 0 </td></tr><tr><td> 1 </td><td> 0 </td><td> 1 </td><td> 0 </td></tr><tr><td> 1 </td><td> 1 </td><td> 0 </td><td> 1 </td></tr></table><p><span class="highlight"> Sum = A XOR B </span> (exclusive or), <span class="highlight"> Carry = A AND B </span></p><h3> The Full Adder </h3><p> A full adder adds two bits plus a carry-in, producing sum and carry-out. A full adder is two half adders combined. By chaining full adders, we can add multi-bit numbers: </p><div class="code-block"> Example: Adding 5 + 3 in binary 101 (5) + 011 (3) ------- 1000 (8) Bit 0: 1 + 1 = 10 (sum 0, carry 1) Bit 1: 0 + 1 + 1(carry) = 10 (sum 0, carry 1) Bit 2: 1 + 0 + 1(carry) = 10 (sum 0, carry 1) Bit 3: 0 + 0 + 1(carry) = 1 (sum 1, carry 0) Result: 1000 (8) </div><h3> Half Adder Circuit </h3><div class="svg-container"><svg height="320" viewbox='0 0 500 320' width="500" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 7'><text fill="#53d8a8" font-size="14" font-weight="bold" text-anchor="middle" x="250" y="25"> Half Adder Logic Circuit </text><g><text fill="#aaa" font-size="11" x="30" y="60"> Input A </text><line stroke="#e94560" stroke-width="2" x1="30" x2="60" y1="70" y2="70"></line><text fill="#aaa" font-size="11" x="30" y="110"> Input B </text><line stroke="#e94560" stroke-width="2" x1="30" x2="60" y1="120" y2="120"></line></g><g><text fill="#53d8a8" font-size="12" font-weight="bold" x="150" y="45"> Sum Path: A XOR B </text><line stroke="#e94560" stroke-width="2" x1="60" x2="90" y1="70" y2="70"></line><line stroke="#e94560" stroke-width="2" x1="60" x2="90" y1="120" y2="85"></line><path d='M 90 65 Q 95 65 105 77.5 Q 95 90 90 90 Q 95 85 95 70' fill="none" stroke="#53d8a8" stroke-width="2"></path><line stroke="#53d8a8" stroke-width="2" x1="105" x2="140" y1="77.5" y2="77.5"></line><circle cx="140" cy="77.5" fill="#53d8a8" r="3"></circle><text fill="#53d8a8" font-size="11" x="160" y="85"> Sum (XOR) </text></g><g><text fill="#53d8a8" font-size="12" font-weight="bold" x="150" y="155"> Carry Path: A AND B </text><line stroke="#e94560" stroke-width="2" x1="60" x2="90" y1="70" y2="160"></line><line stroke="#e94560" stroke-width="2" x1="60" x2="90" y1="120" y2="180"></line><path d='M 90 155 L 90 185 Q 110 185 110 170 Q 110 155 90 155' fill="none" stroke="#53d8a8" stroke-width="2"></path><line stroke="#53d8a8" stroke-width="2" x1="110" x2="140" y1="170" y2="170"></line><circle cx="140" cy="170" fill="#53d8a8" r="3"></circle><text fill="#53d8a8" font-size="11" x="160" y="178"> Carry (AND) </text></g><g><text fill="#53d8a8" font-size="12" font-weight="bold" x="50" y="240"> Half Adder Truth Table: </text><line stroke="#border" stroke-width="1" x1="50" x2="250" y1="250" y2="250"></line><text fill="#aaa" font-size="10" x="60" y="267"> A B | Sum Carry </text><line stroke="#border" stroke-width="1" x1="50" x2="250" y1="272" y2="272"></line><text fill="#eee" font-size="10" x="60" y="288"> 0 0 | 0 0 </text><text fill="#eee" font-size="10" x="60" y="305"> 0 1 | 1 0 </text><text fill="#eee" font-size="10" x="60" y="322"> 1 0 | 1 0 </text><text fill="#eee" font-size="10" x="180" y="288"> 1 1 | 0 1 </text></g></svg></div><h3> Flip-Flops (Memory) </h3><p> A <span class="highlight"> flip-flop </span> is a circuit that can hold a state (0 or 1) and maintain it indefinitely until changed. The simplest flip-flop uses two cross-coupled NAND gates: </p><div class="code-block"> SET input ‚îÄ‚îÄ‚îê ‚îú‚îÄ NAND ‚îÄ‚îÄ‚îê ‚îÇ ‚îú‚îÄ Q output (1) ‚îå‚îÄ‚îÄ‚î§ ‚îÇ ‚îÇ ‚îî‚îÄ NAND ‚îÄ‚îÄ‚îò ‚îÇ ‚Üì RESET input Q-bar output (0) </div><p> When SET is triggered, Q becomes 1 and stays 1 even after the input goes away. When RESET is triggered, Q becomes 0. This is the foundation of digital memory. </p><h3> Registers and Counters </h3><p><span class="highlight"> Registers </span> are groups of flip-flops that store multi-bit numbers. An 8-bit register can store any value from 0 to 255 and hold it until new data is loaded. </p><p><span class="highlight"> Counters </span> are circuits that increment or decrement automatically with each clock pulse, used for timing and sequencing operations. </p></section><section id="memory-storage"><h2> 10. Memory & Storage </h2><p> A computer is useless without a way to store data‚Äîboth during computation (memory) and permanently (storage). </p><h3> Magnetic Core Memory </h3><p> Before semiconductors, computers used <span class="highlight"> magnetic core memory </span> : tiny ferrite rings threaded on wires in a 3D grid. Each ring could be magnetized in one of two directions, storing a 1 or 0. Reading required a destructive read (the ring had to be rewritten), but cores were reliable and retained data without power. </p><h3> Paper Tape and Punch Cards </h3><p><span class="highlight"> Paper tape </span> stores data as holes punched through tape. Readers detect hole presence (1) or absence (0). Early computers used paper tape for both programs and data input/output. </p><p><span class="highlight"> Punch cards </span> (IBM 80-column cards) stored one row of data per card. A deck of cards represented a complete program or dataset. Operators sorted cards by hand and fed them into readers. </p><h3> Magnetic Tape and Disk </h3><p><span class="highlight"> Magnetic tape </span> works like audio tape: data is stored as magnetic patterns on a plastic tape. Access is sequential (you must wind through the tape to find data). </p><p><span class="highlight"> Magnetic disk </span> (hard drive concept) stores data on a spinning platter's surface. Access is random (the read head can jump to any position). Disks are faster than tape for data retrieval. </p><div class="note"><strong> Memory vs. Storage: </strong><ul style='margin-left: 1.5rem; margin-top: 0.5rem;'><li><strong> Memory (RAM): </strong> Fast, volatile (loses data when powered off), small capacity (gigabytes to terabytes in modern systems) </li><li><strong> Storage: </strong> Slower, non-volatile (retains data when powered off), large capacity (terabytes to exabytes) </li></ul></div></section><section id="programming"><h2> 11. Programming Fundamentals </h2><p> A computer without instructions is just a pile of components. Programming is the art of encoding instructions that tell the computer what to do. </p><h3> What is a Program? </h3><p> A program is a sequence of instructions executed one after another (with jumps for loops and conditionals). Each instruction tells the CPU to: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Load data from memory into a register </li><li> Perform arithmetic or logic on data in registers </li><li> Store results back to memory </li><li> Jump to a different instruction (if a condition is met) </li></ul><h3> Machine Code vs. Assembly Language </h3><p><span class="highlight"> Machine code </span> is the raw language of the CPU: sequences of 1s and 0s (or hex numbers). Example: </p><div class="code-block"> 10110000 01100001 (Load 97 into register A) 01100100 11000100 (Add 196 to register A) 10010100 (Store register A to memory) </div><p><span class="highlight"> Assembly language </span> uses mnemonics (short words) to represent instructions, making programming more human-readable: </p><div class="code-block"> MOV A, 61h ; Load 97 (0x61) into register A ADD A, C4h ; Add 196 (0xC4) to A MOV [100h], A ; Store A to memory address 0x100 </div><p> An <span class="highlight"> assembler </span> program converts assembly code to machine code. Higher-level languages (like C or Python) compile to assembly or machine code. </p><h3> Algorithms </h3><p> An algorithm is a step-by-step procedure to solve a problem. Examples: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li><span class="highlight"> Sorting (Bubble Sort): </span> Compare adjacent elements, swap if out of order, repeat until sorted </li><li><span class="highlight"> Searching (Binary Search): </span> In a sorted list, divide in half and check if target is higher or lower, repeat until found </li><li><span class="highlight"> Arithmetic: </span> Step-by-step procedures like long division or square root calculation </li></ul><h3> Flowcharts </h3><p> A flowchart is a visual representation of an algorithm: </p><div class="svg-container"><svg height="450" viewbox='0 0 400 450' width="400" xmlns="http://www.w3.org/2000/svg" aria-label='Computing & Logic diagram 8'><text fill="#53d8a8" font-size="14" font-weight="bold" text-anchor="middle" x="200" y="25"> Flowchart: Finding the Maximum of Two Numbers </text><g><ellipse cx="200" cy="60" fill="none" rx="40" ry="25" stroke="#53d8a8" stroke-width="2"></ellipse><text fill="#eee" font-size="12" text-anchor="middle" x="200" y="65"> START </text></g><line marker-end="url(#arrowhead)" stroke="#aaa" stroke-width="2" x1="200" x2="200" y1="85" y2="110"></line><g><path d='M 160 130 L 200 110 L 240 130 L 200 150 Z' fill="none" stroke="#e94560" stroke-width="2"></path><text fill="#eee" font-size="11" text-anchor="middle" x="200" y="135"> Input: A, B </text></g><line stroke="#aaa" stroke-width="2" x1="200" x2="200" y1="150" y2="175"></line><g><path d='M 200 175 L 260 220 L 200 265 L 140 220 Z' fill="none" stroke="#53d8a8" stroke-width="2"></path><text fill="#eee" font-size="11" text-anchor="middle" x="200" y="225"> A > B? </text></g><line stroke="#aaa" stroke-width="2" x1="260" x2="310" y1="220" y2="220"></line><text fill="#aaa" font-size="10" x="280" y="210"> YES </text><line stroke="#aaa" stroke-width="2" x1="200" x2="200" y1="265" y2="290"></line><text fill="#aaa" font-size="10" x="210" y="280"> NO </text><g><path d='M 310 200 L 350 220 L 310 240 L 270 220 Z' fill="none" stroke="#e94560" stroke-width="2"></path><text fill="#eee" font-size="11" text-anchor="middle" x="310" y="225"> Max = A </text></g><line stroke="#aaa" stroke-width="2" x1="310" x2="310" y1="240" y2="350"></line><line stroke="#aaa" stroke-width="2" x1="310" x2="200" y1="350" y2="350"></line><g><path d='M 160 310 L 200 290 L 240 310 L 200 330 Z' fill="none" stroke="#e94560" stroke-width="2"></path><text fill="#eee" font-size="11" text-anchor="middle" x="200" y="315"> Max = B </text></g><line stroke="#aaa" stroke-width="2" x1="200" x2="200" y1="330" y2="350"></line><g><ellipse cx="200" cy="375" fill="none" rx="40" ry="25" stroke="#53d8a8" stroke-width="2"></ellipse><text fill="#eee" font-size="12" text-anchor="middle" x="200" y="380"> END </text></g><defs><marker id="arrowhead" markerheight="10" markerwidth="10" orient="auto" refx="5" refy="5"><polygon fill="#aaa" points='0 0, 10 5, 0 10'></polygon></marker></defs></svg></div><p class="note"> Flowcharts help visualize program logic before writing code. Modern programming uses pseudocode (English-like descriptions) or directly writes in high-level languages, but the underlying concepts remain the same: sequences, conditionals, and loops. </p></section><section id="path-forward"><h2> 12. The Path Forward </h2><p> We've traced the path from logic gates to digital circuits. The next leap is scale: packing millions or billions of transistors onto a single chip. This requires overcoming enormous engineering challenges. </p><h3> Integrated Circuits (ICs) </h3><p> An <span class="highlight"> integrated circuit </span> puts many transistors on a single chip of silicon. Early ICs (1960s) had dozens of transistors. Modern processors have billions. </p><h3> Moore's Law </h3><p> In 1965, Gordon Moore observed that the number of transistors on a chip doubled approximately every 2 years. This trend, known as <span class="highlight"> Moore's Law </span> , held for decades: </p><div class="code-block"> 1971: Intel 4004 - 2,300 transistors 1982: Intel 286 - 134,000 transistors 2003: Intel Pentium 4 - 42,000,000 transistors 2023: Modern CPUs - 50,000,000,000+ transistors </div><p> This exponential growth is ending (physical limits of silicon), but it powered the computer revolution. </p><h3> What's Needed: The Manufacturing Challenge </h3><p> To build modern chips, you need: </p><div class="subsection"><h4> 1. Pure Silicon </h4><p> Silicon must be 99.9999999% pure. Impurities would ruin the chip. This requires sophisticated purification processes. </p></div><div class="subsection"><h4> 2. Crystal Growth </h4><p> Pure silicon is grown into large single crystals (ingots) under controlled conditions, then sliced into wafers. </p></div><div class="subsection"><h4> 3. Photolithography </h4><p> The key manufacturing step. A pattern is projected onto a light-sensitive chemical on the wafer, then developed like a photograph. This creates tiny transistor features (now measured in nanometers‚Äîbillionths of a meter). </p></div><div class="subsection"><h4> 4. Doping and Etching </h4><p> Dopants (impurities) are added to create P and N regions. Plasma etching removes material to form trenches and connections. </p></div><div class="subsection"><h4> 5. Clean Rooms </h4><p> A single dust particle can ruin a chip. Manufacturing occurs in cleanrooms with filtered air, controlled temperature, and workers in protective suits. Cleanroom technology is extremely expensive. </p></div><h3> The Knowledge Needed to Rebuild </h3><p> To reconstruct computing from scratch, you would need: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Deep understanding of semiconductor physics and materials science </li><li> Expertise in photolithography and vacuum systems </li><li> Precision engineering for mechanical and thermal control </li><li> Software stack: assemblers, compilers, operating systems </li><li> Decades of development time and billions in capital investment </li></ul><h3> A More Realistic Path Forward </h3><p> Rather than starting from transistors, a recovering civilization would likely: </p><ol style='margin-left: 1.5rem; margin-bottom: 1rem;'><li> Redevelop relay logic (mechanical but understandable) </li><li> Progress to vacuum tubes, then discrete transistors </li><li> Build simple digital circuits (adders, registers, memory) </li><li> Construct a basic computer from these parts </li><li> Develop assembly language and basic software </li><li> Eventually, if resources allow, move toward integrated circuits </li></ol><p> The knowledge is the barrier, not the materials. Silicon is abundant, but the expertise to purify it, understand photolithography, and manage cleanroom processes took humanity decades to develop. </p></section><section style='border-left-color: var(--accent);'><h2> Summary: The Path from Abacus to Computer </h2><p> Computing is fundamentally about representation (numbers, binary), manipulation (logic gates), and control (stored programs). The evolution from tally marks to modern processors is a journey of: </p><ul style='margin-left: 1.5rem; margin-bottom: 1rem;'><li><strong> Abstraction: </strong> From physical objects (beads, gears) to abstract concepts (bits, algorithms) </li><li><strong> Automation: </strong> From manual calculation to machines that follow encoded instructions </li><li><strong> Speed: </strong> From mechanical (seconds per calculation) to electronic (billions per second) </li><li><strong> Scale: </strong> From individual devices to billions of transistors on a chip </li></ul><p> Each step‚Äîabacus, mechanical calculator, relay computer, vacuum tube computer, transistor computer, integrated circuit‚Äîbuilt on the previous. Understanding this progression is essential for anyone seeking to rebuild civilization's computing foundation. </p></section></div><div class="common-mistakes"><h3> Common Mistakes </h3><ul><li> Add specific common mistakes here based on the guide content </li></ul></div><div class="notes-section"><div class="notes-header"><span> My Notes </span><span class="notes-toggle"> ‚ñº </span></div><div class="notes-content"><textarea class="notes-textarea" id="guide-notes-text" placeholder='Add your personal notes here. They will be saved automatically.'></textarea><div class="notes-actions"><button class="save-notes-btn" id="save-notes-btn"> Save Notes </button><span class="notes-status" id="notes-status"></span></div></div></div><div class="notes-content"><textarea class="notes-textarea" id="guide-notes-text" placeholder='Add your personal notes here. They will be saved automatically.'></textarea><div class="notes-actions"><button class="save-notes-btn" id="save-notes-btn"> Save Notes </button><span class="notes-status" id="notes-status"></span></div></div></div><footer><p> Computing & Logic: From Tally Marks to Digital Computers </p><p style='font-size: 0.9rem; margin-top: 1rem;'> This compendium is designed to preserve essential knowledge for rebuilding technological civilization. </p></footer><div style='max-width:900px;margin:2rem auto;padding:2rem;border-top:2px solid #2a2a4a'><h3 style="color:#e94560;font-size:0.85rem;text-transform:uppercase;letter-spacing:2px;margin-bottom:1rem"> Related Guides </h3><div style="display:flex;flex-wrap:wrap;gap:0.75rem"><a href="electricity.html" style='background:#16213e;color:#53d8a8;padding:0.5rem 1rem;border-radius:8px;text-decoration:none;font-size:0.9rem;border:1px solid #2a2a4a'> Electricity </a><a href="mathematics.html" style='background:#16213e;color:#53d8a8;padding:0.5rem 1rem;border-radius:8px;text-decoration:none;font-size:0.9rem;border:1px solid #2a2a4a'> Mathematics </a><a href="ham-radio.html" style='background:#16213e;color:#53d8a8;padding:0.5rem 1rem;border-radius:8px;text-decoration:none;font-size:0.9rem;border:1px solid #2a2a4a'> Ham & Radio </a><a href="education-teaching.html" style='background:#16213e;color:#53d8a8;padding:0.5rem 1rem;border-radius:8px;text-decoration:none;font-size:0.9rem;border:1px solid #2a2a4a'> Education & Teaching </a><a href="advanced-materials.html" style='background:#16213e;color:#53d8a8;padding:0.5rem 1rem;border-radius:8px;text-decoration:none;font-size:0.9rem;border:1px solid #2a2a4a'> Advanced & Materials </a></div></div><button id="back-to-top" title='Back to top'> ‚Üë </button><script>
 (function() {
 // Initialize theme from localStorage
 const savedTheme = localStorage.getItem('compendium-theme') || 'dark';
 document.documentElement.setAttribute('data-theme', savedTheme);
 // Theme toggle
 const themeToggle = document.getElementById('theme-toggle');
 if(themeToggle) {
 themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
 themeToggle.addEventListener('click', function() {
 const current = document.documentElement.getAttribute('data-theme');
 const next = current === 'dark' ? 'light' : 'dark';
 document.documentElement.setAttribute('data-theme', next);
 localStorage.setItem('compendium-theme', next);
 themeToggle.textContent = next === 'dark' ? '‚òÄÔ∏è' : 'üåô';
 });
 }
 // Progress tracking
 const guideId = location.pathname.split('/').pop().replace('.html', '');
 const progress = JSON.parse(localStorage.getItem('compendium-progress') || '{}');
 const markBtn = document.getElementById('mark-read-btn');
 if(markBtn) {
 if(progress[guideId]) {
 markBtn.textContent = '‚úì Completed';
 markBtn.classList.add('completed');
 }
 markBtn.addEventListener('click', function() {
 progress[guideId] = {
 completed: true,
 date: new Date().toISOString()
 };
 localStorage.setItem('compendium-progress', JSON.stringify(progress));
 markBtn.textContent = '‚úì Completed';
 markBtn.classList.add('completed');
 });
 }
 // Notes system
 const notesKey = 'compendium-notes-' + guideId;
 const notesArea = document.getElementById('guide-notes-text');
 const savedNotes = localStorage.getItem(notesKey) || '';
 if(notesArea) {
 notesArea.value = savedNotes;
 }
 const saveNotesBtn = document.getElementById('save-notes-btn');
 if(saveNotesBtn) {
 saveNotesBtn.addEventListener('click', function() {
 if(notesArea) {
 localStorage.setItem(notesKey, notesArea.value);
 const status = document.getElementById('notes-status');
 if(status) {
 status.textContent = 'Saved!';
 setTimeout(function() {
 status.textContent = '';
 }, 2000);
 }
 }
 });
 }
 // Notes toggle
 const notesHeader = document.querySelector('.notes-header');
 const notesContent = document.querySelector('.notes-content');
 const notesToggle = document.querySelector('.notes-toggle');
 if(notesHeader) {
 notesHeader.addEventListener('click', function() {
 if(notesContent) {
 notesContent.classList.toggle('open');
 }
 if(notesToggle) {
 notesToggle.classList.toggle('open');
 }
 });
 }
 // Back to top
 const backToTop = document.getElementById('back-to-top');
 if(backToTop) {
 window.addEventListener('scroll', function() {
 backToTop.style.display = window.scrollY > 300 ? 'block' : 'none';
 });
 backToTop.addEventListener('click', function() {
 window.scrollTo({top: 0, behavior: 'smooth'});
 });
 }
})();
 </script><button id="back-to-top" title='Back to top'> ‚Üë </button><script>
 (function() {
 // Initialize theme from localStorage
 const savedTheme = localStorage.getItem('compendium-theme') || 'dark';
 document.documentElement.setAttribute('data-theme', savedTheme);
 // Theme toggle
 const themeToggle = document.getElementById('theme-toggle');
 if(themeToggle) {
 themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
 themeToggle.addEventListener('click', function() {
 const current = document.documentElement.getAttribute('data-theme');
 const next = current === 'dark' ? 'light' : 'dark';
 document.documentElement.setAttribute('data-theme', next);
 localStorage.setItem('compendium-theme', next);
 themeToggle.textContent = next === 'dark' ? '‚òÄÔ∏è' : 'üåô';
 });
 }
 // Progress tracking
 const guideId = location.pathname.split('/').pop().replace('.html', '');
 const progress = JSON.parse(localStorage.getItem('compendium-progress') || '{}');
 const markBtn = document.getElementById('mark-read-btn');
 if(markBtn) {
 if(progress[guideId]) {
 markBtn.textContent = '‚úì Completed';
 markBtn.classList.add('completed');
 }
 markBtn.addEventListener('click', function() {
 progress[guideId] = {
 completed: true,
 date: new Date().toISOString()
 };
 localStorage.setItem('compendium-progress', JSON.stringify(progress));
 markBtn.textContent = '‚úì Completed';
 markBtn.classList.add('completed');
 });
 }
 // Notes system
 const notesKey = 'compendium-notes-' + guideId;
 const notesArea = document.getElementById('guide-notes-text');
 const savedNotes = localStorage.getItem(notesKey) || '';
 if(notesArea) {
 notesArea.value = savedNotes;
 }
 const saveNotesBtn = document.getElementById('save-notes-btn');
 if(saveNotesBtn) {
 saveNotesBtn.addEventListener('click', function() {
 if(notesArea) {
 localStorage.setItem(notesKey, notesArea.value);
 const status = document.getElementById('notes-status');
 if(status) {
 status.textContent = 'Saved!';
 setTimeout(function() {
 status.textContent = '';
 }, 2000);
 }
 }
 });
 }
 // Notes toggle
 const notesHeader = document.querySelector('.notes-header');
 const notesContent = document.querySelector('.notes-content');
 const notesToggle = document.querySelector('.notes-toggle');
 if(notesHeader) {
 notesHeader.addEventListener('click', function() {
 if(notesContent) {
 notesContent.classList.toggle('open');
 }
 if(notesToggle) {
 notesToggle.classList.toggle('open');
 }
 });
 }
 // Back to top
 const backToTop = document.getElementById('back-to-top');
 if(backToTop) {
 window.addEventListener('scroll', function() {
 backToTop.style.display = window.scrollY > 300 ? 'block' : 'none';
 });
 backToTop.addEventListener('click', function() {
 window.scrollTo({top: 0, behavior: 'smooth'});
 });
 }
})();
 </script><script>
// Bookmark system
(function() {
 const guideName = window.location.pathname.split('/').pop();
 const bookmarks = JSON.parse(localStorage.getItem('compendium-bookmarks') || '{}');
 // Add bookmark icons to all h2 elements
 document.querySelectorAll('h2').forEach((h2, i) => {
 const id = h2.id || 'section-' + i;
 if (!h2.id) h2.id = id;
 const key = guideName + '#' + id;
 const btn = document.createElement('button');
 btn.className = 'bookmark-star';
 btn.textContent = bookmarks[key] ? '‚òÖ' : '‚òÜ';
 btn.style.cssText = 'background:transparent;border:none;font-size:1.3em;cursor:pointer;color:' + (bookmarks[key] ? 'var(--accent)' : 'var(--muted)') + ';margin-left:10px;vertical-align:middle;';
 btn.onclick = function(e) {
 e.preventDefault();
 const bm = JSON.parse(localStorage.getItem('compendium-bookmarks') || '{}');
 if (bm[key]) { delete bm[key]; btn.textContent = '‚òÜ'; btn.style.color = 'var(--muted)'; }
 else { bm[key] = { guide: guideName, section: h2.textContent.replace('‚òÜ','').replace('‚òÖ','').trim(), timestamp: Date.now() }; btn.textContent = '‚òÖ'; btn.style.color = 'var(--accent)'; }
 localStorage.setItem('compendium-bookmarks', JSON.stringify(bm));
 };
 h2.appendChild(btn);
 });
 // Add floating bookmarks panel button
 const panelBtn = document.createElement('button');
 panelBtn.innerHTML = 'üîñ';
 panelBtn.title = 'View Bookmarks';
 panelBtn.style.cssText = 'position:fixed;bottom:70px;right:20px;width:50px;height:50px;border-radius:50%;background:var(--accent2);color:white;border:none;font-size:1.5em;cursor:pointer;z-index:998;box-shadow:0 2px 8px rgba(0,0,0,0.3);';
 panelBtn.onclick = function() {
 const bm = JSON.parse(localStorage.getItem('compendium-bookmarks') || '{}');
 const guideBookmarks = Object.entries(bm).filter(([k]) => k.startsWith(guideName));
 let panel = document.getElementById('bookmark-panel');
 if (panel) { panel.remove(); return; }
 panel = document.createElement('div');
 panel.id = 'bookmark-panel';
 panel.style.cssText = 'position:fixed;bottom:130px;right:20px;width:300px;max-height:400px;overflow-y:auto;background:var(--surface);border:2px solid var(--accent2);border-radius:8px;padding:15px;z-index:999;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
 let html = '<h4 style="color:var(--accent2);margin:0 0 10px 0;">üîñ Bookmarks in This Guide</h4>';
 if (guideBookmarks.length === 0) html += '<p style="color:var(--muted);">No bookmarks yet. Click ‚òÜ next to any heading to bookmark it.</p>';
 else guideBookmarks.forEach(([key, val]) => {
 const sectionId = key.split('#')[1];
 html += '<a href="#'+sectionId+'" style="display:block;padding:8px;margin:4px 0;background:var(--card);border-radius:4px;color:var(--text);text-decoration:none;" onclick="document.getElementById(\'bookmark-panel\').remove();">‚òÖ '+val.section+'</a>';
 });
 html += '<button onclick="this.parentElement.remove()" style="margin-top:10px;padding:6px 12px;background:var(--card);color:var(--text);border:1px solid var(--border);border-radius:4px;cursor:pointer;width:100%;">Close</button>';
 panel.innerHTML = html;
 document.body.appendChild(panel);
 };
 document.body.appendChild(panelBtn);
})();
</script></main><script src="../shared/theme-sync.js"></script><script src="js/shared.js"></script></body></html>